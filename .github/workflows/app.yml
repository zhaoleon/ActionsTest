name: 'NCar-Unreal-Builder'

run-name: App build 

on:
  push:
  workflow_dispatch:
    inputs:
      app_version:
        description: 'The version of the app to be built'
        required: true
        default: '0.1'
      environment:
        description: 'The deployment environment'
        required: true
        type: choice
        options:
          - 'DEV'
          - 'UAT'
          - 'PROD'
        default: 'DEV'
      build_config:
        description: 'Configuration to use'
        type: choice
        required: true
        options:
          - 'Development'
          - 'Debug'
          - 'Shipping'
        default: 'Development'
      platform:
        description: 'Platform to build for'
        type: choice
        required: false
        options:
          - 'Win64'
          - 'Linux'
        default: 'Linux'
      maps:
        description: 'Maps to be packaged'
        required: false
      archive:
        description: 'Whether to archive'
        type: boolean
        required: true
        default: true
      # archive_path:
      #   description: 'Archive Path'
      #   required: false
      #   default: '/home/ubuntu/ActionsOutput/'

env: 
  app_version: ${{ inputs.app_version !='' && inputs.app_version || '0.1' }}
  tag: ${{ inputs.app_version !='' && startsWith(inputs.app_version, 'v') || false }}
  environment: ${{ inputs.environment != '' && inputs.environment || 'DEV' }} 
  build_config: ${{ inputs.build_config !='' && inputs.build_config || 'Development' }} 
  platform: ${{ inputs.platform !='' && inputs.platform || 'Linux' }} 
  archive: ${{ inputs.archive && false || true }}
  archive_path: '${{ github.workspace }}/Output/'
  maps: ${{ inputs.maps !='' && inputs.maps || '' }}

jobs:
  clean-workspace:
    name: Clean the workflow workspace
    runs-on: [self-hosted, CICDForUnreal, Linux]

    steps:
      # Clean the workspace by deleting the old version
      - name: Clean workspace
        run: |
          echo 'Deleting existing workspace: ${{ github.workspace }} before checkout the repo to ensure the project file is fresh'
          rm -rf ${{ github.workspace }}/*

  build-app:
    name: Build unreal project
    runs-on: [self-hosted, CICDForUnreal, Linux]
    needs: clean-workspace
    outputs: 
      dispatch_release: ${{ steps.check-if-release-dispatch.outputs.publish_release }}
      push_release: ${{ steps.check-if-release-push.outputs.publish_release }}

    steps:
      - name: Checkout project
        uses: actions/checkout@v4
        with: 
          lfs: true
          fetch-depth: 0
          repository: ${{ github.repository }}

      - name: Build cook package
        uses: ./.github/actions/buildcook
        with:
          app_version: ${{ env.app_version }} 
          environment: ${{ env.environment }} 
          build_config: ${{ env.build_config }} 
          platform: ${{ env.platform }} 
          maps: ${{ env.maps}} 
          archive: ${{ env.archive }} 
          archive_path: ${{ env.archive_path }}

      - name: Check if publish release
        id: check-if-release-dispatch
        run: |
          if [ ${{ startsWith(env.app_version, 'v') }}]; then
            echo "publish_release=true" >> $GITHUB_OUTPUT
            echo 'Build: App version starts with v, it will publish to release'
          else
            echo "publish_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Check if publish release on push
        id: check-if-release-push
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        run: |
          # TODO: check the push tag starts with v
          echo "publish_release=true" >> $GITHUB_OUTPUT
          echo 'Build: Pushed tag starts with v, it will publish to release'

  deploy:
    runs-on: [self-hosted, CICDForUnreal, Linux]
    if: ${{ needs.build-app.outputs.dispatch_release }} || ${{ needs.build-app.outputs.push_release }}

    permissions:
      contents: write
      pull-requests: write
      repository-projects: write

    name: Create release
    needs: build-app
    
    defaults:
      run:
        working-directory: ${{ env.archive_path }} 

    env: 
      ArchiveName: NCarApp_${{ github.run_number }}.zip
    
    steps:
      - name: Get repo tags
        id: get-tags
        uses: actions/github-script@v7
        with:
          script: |
            const {data} = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const formattedTags = data.map(tag => tag.name);
            return formattedTags;

      - name: Output tags
        run: |
          echo 'Existing tags: ${{ steps.get-tags.outputs.result }}'

      - name: Check tag availability
        id: check-tag
        run: |
          tags=${{ steps.get-tags.outputs.result }}
          item=${{ env.app_version }}
          if [ "${tags[@]}" =~ "$item" ]; then
            echo '::error::Error: Version ${{ env.app_version }} already exists, please reset it with a new one'
            exit 4
          fi
              
      - name: Create tag
        id: create-tag
        if: 
          ${{ env.tag }}
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/tags/${{ env.app_version }}',
              sha: context.sha
            })

      - name: Zip archive
        run: |
          echo 'zip command: zip -rqu ${{env.ArchiveName}} ${{ env.archive_path }}'
          zip -rqu ${{env.ArchiveName}} .

      - name: Create release
        id: create_release
        uses: actions/create-release@v1
        env: 
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with: 
          tag_name: ${{ env.app_version }}
          release_name: Release ${{ github.ref }}.${{ github.run_number }}
          body: |
            Release: ${{ env.app_version }}
          draft: false
          prerelease: false
          
      - name: Upload release asset
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env: 
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps 
          asset_path: ${{env.archive_path}}/${{env.ArchiveName}}
          asset_name: ${{env.ArchiveName}}
          asset_content_type: application/zip
